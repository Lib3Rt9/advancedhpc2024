Test 1 - Base implementation on CPU

Problem: Super slow!

Causes:
	- Distance Calculation in Loops: Calculating Euclidean distances in loops, especially in both KMeans and FuzzyCMeans, can become computationally heavy for images with many pixels. Each distance calculation is done individually in a loop, which is inefficient for large datasets.
	- Lack of Vectorization: The current implementation calculates distances for each point one at a time. Vectorized operations in libraries like NumPy can dramatically reduce processing time by performing batch computations.
	- Python Loops in predict and fit Methods: The predict and fit methods in both classes use Python loops, which are slower than vectorized operations for large datasets.
	- Membership Matrix in FuzzyCMeans: The membership matrix update step in Fuzzy C-Means is computationally expensive due to the fuzzy exponentiation and multiple distance computations. This step is a known bottleneck.


################################################

Test 2 - Optimization for Test 1

Solve Test 1:
	- Vectorize Euclidean Distance Calculations: To speed up KMeans and FuzzyCMeans, replace the _euclidean_distance method with a vectorized version that computes distances for all pixels in a single operation.
	- Avoid Python Loops with NumPy Broadcasting: Use NumPy broadcasting to assign each pixel to the nearest centroid in a single step, bypassing Python loops and boosting performance.


Test 2 is using vectorized calculation for calculating the distances between centroids and the points
	class Kmean is using Euclidean vectorize
	class FuzzyCMean is using NumPy's broadcasting and 'np.linalg.norm'


################################################

Test 3 - GPU implementation - based on Test 2

Problem:
	SOLVED - Not able to run method
	SOLVED - Warning divided by 0 when calculating new_centroids
	SOLVED - Quantized image has only 1 cluster/color
	- Class FuzzyCMeans not being updated yet

Causes:
	- problem with thread block x, y
	- some cluster has 0 points
	- error in handling NAN and Inf value at this line: `new_centroids = np.nan_to_num(new_centroids, nan=0, posinf=255, neginf=0)  # Handle NaNs and infinities`

Solution:
	- Use thread per block: (16, 16) instead of 256
	- Error handling - need at least 1 point per cluster
	- remove line for handling NAN and Inf


################################################

Test 4 - GPU implemetation for FuzzyCMeans
	- based on Test 3

Problem:
	- Warning dividing to 0 ?
	- NAN and Inf values causing quantized image has only 1 cluster. ?
	SOLVED - Quantize image with GPU causing only 1 color - all centroids are almost in the same position -> all in 1 cluster.	

Causes:
	- 1 color quantize: problem with calculating distances in membership matrix perhaps?

Solution:
	- ? update membership matrix with GPU along calculating centroids


################################################

Test 5 - GPU optimization
	- based on Test 4

